+++
title = "iOS多线程中的锁"
date = "2017-12-01T00:00:00Z"
categories = ["iOS"]
keywords = ["多线程","锁"]
tags = ["多线程","锁"]
draft = false
+++

涉及到多线程共享资源的情况下就避免不了资源竞争的问题，这时候就会用到各种锁，例如，`@synchronized`、`NSLock`、`OSSpinLock`等等，虽然都是锁，但是锁的底层实现也不尽相同。大概可以分为：{{< hl-text blue >}}互斥锁{{< /hl-text >}}、{{< hl-text blue >}}自旋锁{{< /hl-text >}}、{{< hl-text blue >}}递归锁{{< /hl-text >}}、
{{< hl-text blue >}}读写锁{{< /hl-text >}}。

```
{
	lock()//加锁
		doSomeThing()//临界区
	unlock()//解锁
}
```
我们锁的目的是在任何时刻最多只能有一个线程在修改资源，即在任何时刻只能有一个操作者保持锁。

#### 互斥锁
通过一个全局变量来控制某个线程是否可以在某个时刻访问资源，该变量值大于0说明锁正在被使用。如果某个线程在尝试获得锁的是否发现已经被占用，线程挂起，等待锁的释放。

#### 自旋锁
通过一个全局变量来控制某个线程是否可以在某个时刻访问资源，该变量值大于0说明锁正在被使用。如果某个线程在尝试获得锁的是否发现已经被占用，进入忙等状态，直到获得锁。

>以上可以看出，互斥锁和自旋锁很类似，稍有不同的地方在于当处于等待状态的时候各自的线程是怎么调度的。互斥锁即使时间片还未用尽，互斥锁也会直接挂起，这样就减少了CPU的开销。但是这时候会进行上下文（线程）的切换，也会带来一定的开销，适合I/O密集型操作。自旋锁，顾名思义，即使处于等待状态线程也不会挂起，一直处于忙等状态，类似于一直在进行一个whilte循环。这样增加了CPU的开销，所以对于需要保持上下文的任务必须要使用自旋锁，同时它是不能被抢占的（高优先级会抢占低优先级的进程），适用于CPU密集型的任务。


#### 递归锁
对于递归调的时候我们不能简单的使用某个锁来锁住临界区，这样就会造成死锁，必须要使用递归锁。当加锁的时候，变量就会加1，解锁的时候开始减1，直到值为0的时候释放锁。